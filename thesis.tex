\documentclass[en]{pracamgr}

% ======== Custom package setup ========
\usepackage{amsthm}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=RoyalBlue,
    pdfpagemode=FullScreen,
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
    language=Haskell,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    escapeinside={(*}{*)},          % if you want to add LaTeX within your code
    tabsize=4
}

% ======== Custom package setup end ========

\autor{Jacek Olczyk}{385896}

\title{Default values in Haskell record fields}
\titlepl{Domyślne wartości pól rekordów w Haskellu}

\kierunek{Computer Science}

\opiekun{PhD. Josef Svenningsson\\
  Chalmers University of Technology\\
}
\opiekunuw{PhD. Marcin Benke\\
  Instytut Informatyki\\
}

  % miesiąc i rok:
\date{X 2022}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
11.3 Informatyka\\ 
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)

% candidates sourced from https://dl.acm.org/ccs

% Software and its engineering
% Software notations and tools
% General programming languages
% Language types
% Functional languages

% Software and its engineering
% Software notations and tools
% General programming languages
% Language features
% Data types and structures

% Software and its engineering
% Software notations and tools
% Formal language definitions
% Syntax

% Software and its engineering
% Software notations and tools
% Context specific languages
% Interface definition languages

\klasyfikacja{D. Software\\
  D.127 TODO pick candidate\\
  D.127.6. Numerical blabalysis}

% Słowa kluczowe:
\keywords{functional programming, Haskell, TODO}

% Tu jest dobre miejsce na Twoje własne makra i środowiska:

\newtheorem{defi}{Definition}[section]
\newcommand{\jcom}[1]{\textcolor{RoyalBlue}{[jo: #1]}}



% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  This thesis presents a prototype implementation of the syntax
  and semantics for specifying the default values for fields 
  of record types in Haskell. The proposed syntax aims to have
  no impact on existing Haskell code and minimal syntactic intrusion
  when the proposed feature is used. The use of default values
  can and will happen only when using the braced record construction
  syntax already present in Haskell. The syntax for defining default 
  values for fields follows recognizable conventions from other
  programming languages in which this feature is present.
  This feature facilitates more seamless integration of Haskell codebases 
  into multi-language codebases unified
  by interface definition languages such as Apache Thrift. 
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Algebraic data types have been a staple of functional programming languages since their earliest days.
A typical extension of their utility for everyday programming is the record syntax, present in most popular functional programming languages.
However, a notable functionality often missing from that feature is the ability to provide default values for individual record fields.
While widely used workarounds are known, they suffer from various problems that a compiler-assisted solution can avoid.

This work aims to solve these problems in the case of the Haskell language by proposing a custom syntax inside record definitions that enables the programmer to provide a default value to any field of a given record type.
In the beginning, we further detail the background and motivation behind these changes. 
Then, we outline the syntactic changes applied to the grammar of Haskell alongside alternative solutions and reasoning behind the final choice.
Following that, we explain in detail the semantic behavior of introduced features and the purely semantic changes to existing constructs.
We also explain the development process and decisions made when implementing the feature in GHC, the leading compiler of the Haskell language.
Finally, we investigate the performance impact of the change on the runtime of the compilation using GHC as well as the compiled programs themselves.
The latter is accomplished by running benchmarks on \jcom{TODO}.


\chapter{Background}\label{r:bg}
\section{Overview of record syntax}
A major drawback algebraic data types usually face when contrasted with data types commonly found in imperative languages (like \texttt{struct} in C) is their unwieldiness when it comes to data structures containing many fields.
While most imperative and virtually all object-oriented languages feature a prominent and easy-to-use syntax for both naming and accessing individual fields of their data structures, the default for most functional languages has been to prefer data structures with unnamed fields.
However, as projects grow larger and larger, having only unnamed data structure fields becomes increasingly cumbersome and error-prone.
Thus, most functional languages provide an alternate record syntax for defining their data types. 

In most cases, record syntax provides two important features: 
the ability to name individual fields of a data structure; 
and the automatic generation of field selector functions which
absolves programmers from having to write the otherwise necessary,
but cumbersome boilerplate code. 
\jcom{example at \url{https://en.wikibooks.org/wiki/Haskell/More_on_datatypes}}
\section{Field defaulting}
\subsection{Introduction}
Despite their relative ubiquity in programming languages, most instances
of record syntax have an important usability feature missing when compared
to their imperative counterparts --- the ability to leave out certain fields empty
when creating a concrete object of a given type. Especially when dealing with
data structures containing a great number of fields, e.g. types that represent
a configuration file, the necessity of providing every field 
of the structure with a value can become unwieldy very quickly. 
\subsection{Prior attempts at solving the issue}
This issue has been heretofore partially mitigated thanks to another common feature of record syntax in programming languages: the record update syntax. 
It allows for the construction of a record in such a way that any unspecified fields are copied over from an already existing record. 
If the author of a type then provides their users with a globally visible ''default'' object with all its fields already filled out, a user can utilize the record update syntax to mimic the desired functionality.

However, this approach is not without its drawbacks.
Firstly, it can prove a challenge if some fields don't lend themselves easily to default values. 
For example, a data type might have an ID component along with invariants guaranteeing its uniqueness. 
In such a situation, great care must be taken when creating a new record to ensure that the ID component is always modified from the value provided by default.
It is also possible to circumvent that using optional types (like Haskell's \texttt{Maybe}), but this makes the data structure cumbersome to use for anything other than its creation.
Unlike it is for its imperative counterpart, this approach does not offer the programmer any automated systems that would detect the absence of such a value.
Given that a major advantage functional languages tout over others is the strength of their automated compile-time error detection, this is an area in which clear improvement can be made.

In some languages, like Haskell, it is also possible to create a record without specifying all of its fields.
However, in that case, the fields are still automatically filled with bottom values.
To make matters worse, such a creation creates compile-time warnings when defining the default record, and no compile-time warnings when some of the bottoms are not replaced.
Because of that, this solution is even worse than the previous one.

Secondly, the necessity of creating a custom object to use as a default can lend itself to improper coding style and more difficulty in codebase navigation.
In order to create a default object, one must first decide on a name that it will be given, which in large codebases necessitates either coming up with a naming convention or dealing with the repercussions of inconsistent naming. 
Furthermore, there is no requirement for the programmers to place the default object in the same place, or even in the same file as the definition of the type itself.
This can quickly make the issue of finding the default object a true detective's task. 

\subsection{Use cases}
Aside from the obvious functionality improvements, allowing default fields in records has some impact on the overall Haskell ecosystem.
Many large multi-language codebases, such as the giant monorepos used by Big Tech companies, use interface definition languages (IDLs) to interface between code written in different languages.
IDLs usually provide this through a language-agnostic syntax for defining data structures. 
This syntax usually (as is the case in Apache Thrift) contains a way to provide default values for fields of the data structures being defined.
Because of that, any language that doesn't natively support default field values in data structures will need to use workarounds before being able to interface with IDLs.
\jcom{TODO: Josef's more detailed background on FB's use case}

\chapter{GHC architecture}
This section contains an abridged overview of the architecture of the frontend of the GHC compiler to serve as background for implementation details provided later.
The compilation process in the GHC compiler consists of 6 main phases \cite{GHCIntermediateForms}, the first 4 of which are:
\begin{enumerate}
  \item Parsing
  \item Renaming
  \item Typechecking 
  \item Desugaring 
\end{enumerate}
These are all the phases that deal with the Haskell AST, mostly unchanged from the parser. 
The last one, the desugarer, desugars the Haskell AST to the much smaller internal language Core, which is used for optimization.
Before discussing the passes themselves, it's worth to describe how GHC deals with modification of the AST throughout the frontend of the compiler.
\section{Trees that grow}
Throughout the phases of the frontend, various data about the Haskell AST is generated (and other becomes no longer needed).
In order to avoid data structure fields or constructors being unused during some phases or having multiple slightly different versions of the same AST type definitions,
a mechanism was introduced in \cite{Najd2017TreesTG} which parameterized the entire syntax tree with a type argument representing the current phase of compilation.
Three distinct phases are available: \texttt{GhcPs}, \texttt{GhcRn}, \texttt{GhcTc},
with the parser producing code parameterized by \texttt{GhcPs}, the renamer converting \texttt{GhcPs} to \texttt{GhcRn},
and the typechecker converting \texttt{GhcRn} to \texttt{GhcTc}. 
With that in mind, when creating a data structure,
the developer writes all constructors and fields common to all phases as they normally would, with a minor exception.
Every type \texttt{T} gets an extra constructor \texttt{XT} (e\texttt{X}tension to \texttt{T}), which allows for phase-specific constructors,
and every constructor \texttt{CtorT} has as its first field set to type \texttt{XCtorT}, to allow for phase-specific constructor fields.
Any type written in extension field or an extension constructor definition is actually a \texttt{type family},
which when parameterized by the phase, allows for a different \texttt{type instance} for each phase.
\section{Compilation phases}
\subsection{Parsing}
GHC does parsing of source code through a monolithic Happy grammar\cite{Happy}, although this wasn't initially the case \cite{Jones1993TheGH}.
The data structures emitted by the parser are often ambiguous as to which production was actually used to parse a given part of the source code.
This is a result of a policy of ''overparse, then filter out the bad cases''\cite{ParserWiki}.
For example, in certain contexts both patterns and expressions are valid, so knowing which grammar derivation to use would require infinite lookahead.
This is solved through a validation monad which allows parsing contexts to specify which constructs are possible, failing the parse on the rest.
Another system of note are the source location and annotation types, which are ingrained into the types that form the Haskell source code AST.
Any parser node has to extract the location and annotation data from its subnodes, and very carefully combine them together,
as there is no automatic mechanism for detecting errors in code like this.

\subsection{Renaming}
The task of the renamer is to match each name usage in the code with the matching definition. 
Its code is intertwined with the typechecker code, and uses the same monad \cite{RenamerWiki}.

\subsection{Typechecking}
Typechecking a module happens concurrently (but not in parallel) with renaming, because of Template Haskell splices.
The typechecker uses the \texttt{Type} type, which is used to type Core, instead of the \texttt{HsType} created by the parser \cite{TypecheckerWiki}.
This is because the typechecking process is quite complicated, and thus requires a data structure that is easy to manipulate.

\subsection{Desugaring}
The desugarer transforms the Haskell AST (with the \texttt{GhcTc} phase indicator) into an explicitly type variant of System FC called Core\cite{CoreWiki}.
The Core language AST consists of very few constructors, and great care is taken to not modify this language when not necessary, 
so any changes that are little more than syntactic sugar should be implemented as part of the desugarer.

\chapter{Syntax}
Among a wide variety of languages supporting providing default values to fields of data structures, there has been a virtually unanimous agreement on the syntax used for providing the default values.
Any language that supports this feature on the compiler level seems to agree on the base syntax being \texttt{field\_name = value}, with minor variations depending on the given language's syntax for field type annotations.
Thus, declaring an integer field with default value of 1 in C++, Java, and likely many others, looks like this: \texttt{\textcolor{Violet}{int} x = \textcolor{BrickRed}{1};}.
As another example, the same is accomplished in TypeScript with the syntax \texttt{x:\ \textcolor{Violet}{number} = \textcolor{BrickRed}{1},}.

\section{Syntax for declaring a default field value}
With that in mind, we needed to accommodate the \texttt{field\_name = value} syntax to existing syntax for Haskell records.
A single field in a Haskell record currently looks like the following:
\begin{lstlisting}[escapeinside={(*}{*)}]
  fieldName :: FieldType
\end{lstlisting}
Considering the above examples, a few alternative approaches for the default value syntax come to mind.

\begin{itemize}
  \item type after value
  \begin{lstlisting}[escapeinside={(*}{*)}]
    fieldName = field_value :: FieldType
  \end{lstlisting}
  \item type after name
  \begin{lstlisting}[escapeinside={(*}{*)}]
    fieldName :: FieldType = field_value
  \end{lstlisting}
  \item variants of both of the above, but allowing for omitting the type of the expression
\end{itemize}

In total four variants, and the one chosen here is the "type after value" approach without omitting the type signature.
\subsection{Order of syntactic components}
To decide between ''type after value'' and ''value after type'', we looked at language constructs already prevalent in existing Haskell code.

%While it is possible for a top-level Haskell binding to be declared both of these ways, the usual preference for Haskell developers is 
A regular top-level Haskell binding with a type annotation can have multiple forms:
\begin{enumerate}
  \item \label{vb:popular} standalone type annotation
  \begin{lstlisting}[escapeinside={(*}{*)}]
    name :: Type 
    name = value
  \end{lstlisting}
  \item \label{vb:good} type after value
  \begin{lstlisting}[escapeinside={(*}{*)}]
    name = value :: Type
  \end{lstlisting}  
  \item \label{vb:bad} value after type
  \begin{lstlisting}[escapeinside={(*}{*)}]
    name :: Type = value
  \end{lstlisting}
\end{enumerate}

By far, the most popular of these variants is \ref*{vb:popular}, but it's not readily adaptable to record fields.
To choose between \ref*{vb:good} and \ref*{vb:bad}, we note that \ref*{vb:bad} is very rarely used in real code.
Furthermore, at first glance, it might seem as if the default value is being assigned to the type, not the field name.
In contrast, \ref*{vb:good} looks like a familiar construct --- a binding name without a type annotation, and its right-hand-side expression with one (and it is already parsed as such by GHC).

\subsection{Omitting the type signature}
It would seem like a good idea to allow users to omit the type signature for a field with a user-supplied default value.
After all, it seems possible to always infer the type from the defaulting expression.
As it turns out, the reality is not that simple.
Many tools that are part of the GHC project currently need to be able to present the type of all fields of a given datatype without the information provided by a full typecheck of the program.
The list of these tools includes the typechecker itself.
While the typechecker itself could theoretically be modified to avoid this problem, forcing a typecheck on other tools (such as Haddock) would unnecessarily slow down their performance without a noticeable gain.
As providing type annotations is a good practice in almost all use cases and virtually all existing code already has to do so for all their record fields, this loss of functionality seems to have negligible cost.


\section{Syntax for use of defaulted fields}

The chosen method for initializing fields with their default value is through braced record syntax.
Because the only other way to construct a record is through a regular constructor function, which cannot have optional arguments (just like all other Haskell functions), braced record syntax is the sole method of assigning default values to fields.
Omitting a given defaulted field is the only requirement for activating the mechanism. 
Since omitting fields in record construction was already allowed (but produced a compile-time warning), no syntax change is necessary.

\jcom{TODO: maybe talk about the possibility of defaulting multiple fields in one line, e.g. ''a = 1, b = 2, c = 3 :: Int'')}

\section{Summary}
Below is a complete example of a Haskell record type with one of its fields defaulted. 
In our view, the final syntax combines the best compromise between readability, new user learning curve, and implementation viability.

\begin{lstlisting}[escapeinside={(*}{*)}]
data NewRecordType
   = NewRecordTypeCtor 
   { fieldName :: SomeType 
   , fieldName2 = expression2 :: SomeType2
   }
\end{lstlisting}
No syntax change is necessary for the case of the usage of default values.


\chapter{Semantics}
\section{Examples}
The semantics for the proposed extension of the language are very simple.
Recall the (slightly renamed) example type from the previous chapter:

\begin{lstlisting}[escapeinside={(*}{*)}]
  data Record1
     = RecordCtor2 
     { field1 :: Int
     , field2 = expression1 :: String
     }
\end{lstlisting}
  
In order to utilize the mechanism inserting default values, usage of the record construction syntax is necessary:

\begin{lstlisting}[escapeinside={(*}{*)}]
  exampleRecord :: Record1
  exampleRecord 
    = RecordCtor1
    { field1 = 12
    -- field2 is initialized with the default value
    }
\end{lstlisting}

Notably, this is the only possible way of constructing a record with a non-$\bot$ default value.
Below we give non-examples of constructions that do not change their semantics with this change (but could reasonably be expected to).
In the first example, the field is initialized with the $\bot$ value, both in the current version of Haskell and with the changes described in this thesis applied to GHC.

\begin{lstlisting}[escapeinside={(*}{*)}]
  data Record2
     = RecordCtor2 
     { field1 :: Int
     , field2 :: String
     }  

  exampleRecord :: Record2
  exampleRecord 
    = RecordCtor2 
    { field1 = 12
    -- field2 is initialized with the (*$\bot$*) value, raising an error when evaluated
    }

\end{lstlisting}

In the second example, we note that record update is not affected by these changes. 
Every unspecified field in the record update will be copied directly from the old record, even if its value is $\bot$.
The example record created by the following code is equal to \texttt{RecordCtor3 \{ field1 = 5, field2 = 4 \}}.

\begin{lstlisting}[escapeinside={(*}{*)}]
  data Record3
     = RecordCtor3
     { field1 = 1 :: Int
     , field2 = 2 :: String
     }  

  baseRecord :: Record3
  baseRecord = RecordCtor3 { field1 = 3, field2 = 4 }

  exampleRecord :: Record3
  exampleRecord 
    = baseRecord
    { field1 = 5
    -- field2 is initialized using the value in baseRecord, not the default value
    }

\end{lstlisting}

\section{A more formal statement}
For precision, we offer a reasonably rigorous semantic description of field defaulting:
\newtheorem{remark}{Description}
\begin{remark}
  \normalfont
  Let $T$ be a type with a record constructor $T'$ containing a field $f$ for which a default expression $e$ has been provided.
  Then, if while calling the constructor $T'$ via the record construction syntax, field $f$ is not given any value, during evaluation the construction happens \textit{as-if} field $f$ had been specified and given the value $e$.
\end{remark}

\section{Notable observations}
Given Haskell's usual semantics as a pure and lazy language, the defaulting expression will only be evaluated at most once, if it's needed.
This allows for arbitrarily complex expressions without risking unnecessarily long runtime of the program. 
Even if the defaulted field's type is a computation inside the \texttt{IO} monad (and thus can be considered to have side effects), the evaluation of the expression only produces instructions for the runtime system without actually executing them.
Thanks to that we can be certain that the default values will behave as expected.

\section{Cross-module behavior}
\jcom{TODO pending further investigation}

\chapter{Implementation}

We implemented the proposed change to the language inside the leading Haskell compiler, GHC (Glorious Haskell Compiler).
The algorithm is a journey that takes the default expression from being declared to being substituted when a field is missing.
It consists of the following main steps:
\begin{enumerate}
  \item Parse the defaulting expression inside the constructor.
  \item Give it a unique name and group it together with top-level bindings so that dependency analysis, renaming and typechecking are performed without disturbances.
  \item Mark defaulted fields as not actually missing.
  \item During desugaring to Core, replace any missing fields with their default values.
\end{enumerate}

The necessary changes made to the GHC code can be broken down into X parts:
\begin{enumerate}
  \item Changes to datatypes
  \item Parser
  \item Renamer
  \item Desugarer
\end{enumerate}

\section{Changes to datatypes} \jcom{Maybe the sections below could use references to specific files?}

\jcom{Now I realize that the fields should have been called default expressions in the code, not initializing expressions...}
For the initial prototype we tried to keep the changes to existing internal GHC data structures to a minimum.
First necessary change was to the \texttt{ConDeclField} type, which represents a single field of a record constructor.
We modify it by adding a field called \texttt{cd\_fld\_ini} of type \texttt{Maybe (LHsExpr pass)}. 
The \texttt{L} prefix in \texttt{LHsExpr} means that the expression contains information about its location in the source file.
The \texttt{pass} parameter signifies the current phase of the compilation \jcom{ref. Trees that grow}.
This modification allows us to pass the defaulting expression from the parser to the renamer.

The renamer then moves information about types and their constructors from the data structures that represent abstract syntax to internal structures that are easier to work with.
There, information about record fields is stored inside the \texttt{FieldLabel} type, to which we added a new field, \texttt{flIniExpr :: Maybe Name}.
The \texttt{Name} refers to the generated name of the binding generated for the expression.

\section{Parser}
Parser uses Happy, a grammar-based parser generator for Haskell.
The existing grammar node for record fields is called \texttt{fielddecl}.
Its only production is \texttt{fielddecl : sig\_vars '::' ctype}.
The above parses a comma-separated list of variable names, followed by the \texttt{::} operator, followed by the type of the field(s).
The names are a list to allow for declaring multiple fields with the same type in one line, e.g. \texttt{a, b, c :: Foo}.
We want to modify it to allow for \texttt{ = expr} between the name of the field and the type.
One obvious solution would be to add another production producing \texttt{var '=' exp '::' ctype} (as we only want to allow a single name to be defaulted on one line).
This unfortunately produces a reduce/reduce conflict, as \texttt{exp} can already contain a type signature. 
We solve this conflict by extracting the production for an expression with a type signature to a separate node, \texttt{typedexp}.
This allows us to parse \texttt{var '=' typedexp}, which forces a type signature and guarantees no conflicts.
The aforementioned production is introduced as a new node, \texttt{varini}, for clarity.

\section{Renamer}
\subsection{Preprocessing}
Before we start the renaming process, we want to make sure we are making as much use of existing GHC piping as possible.
Thus, at the beginning of the renamer, we extract all of the default values for fields into separate bindings.
In the type declarations, the user-provided expressions are then replaced (inside the \texttt{ConDeclField} structures) with simple variable expressions.
The user-provided expressions are given freshly generated names and grouped together with other value declarations for the module.
All the declarations are fed to the renamer in this way, and there the next phase of renaming proceeds.
\subsection{Conversion}
Early in the renaming process, the abstract syntax for type declarations is parsed into more convienient data structures.
It is here that record selector functions are created and their names are placed inside the \texttt{FieldLabel} objects created alongside them.
This means that it's the perfect place for inserting the names of the default expressions into the \texttt{FieldLabel}s.
To do that, before checking individual constructors or fields, a mapping is constructed of all field names from a given type declaration to the names of their default expressions.
\subsection{Missing fields detection}
The fields that have been given default values should be excluded from both the list of missing strict fields (which produces an error when nonempty) and the list of missin nonstrict fields (which only produces a warning).
When detecting if fields are missing, the algorithm compares the available \texttt{FieldLabel}s for the given constructor with the occurrences provided in a given expression.
Thus, to exclude defaulted fields, it is sufficient to filter out the \texttt{FieldLabel}s that have their \texttt{flIniExpr} field set to a \texttt{Just} value.

\section{Desugarer}
During desugaring, we need to fill any unspecified record fields with the variable name corresponding to the appropriate default expression.
Normally, the desugarer fills all missing fields with error ($\bot$) values.
Given that the desugarer has access to the \texttt{FieldLabel}s of the arguments being desugared, we can check if they contain the default expression and desugar the field to contain the variable name instead of an error.


\chapter{Benchmarks}
\jcom{TODO}


\bibliographystyle{acm} \bibliography{bibliography}


% \bibitem[Blar16]{eb1} Elizjusz Blarbarucki, \textit{O pewnych
%     aspektach pewnych aspektów}, Astrolog Polski, Zeszyt 16, Warszawa
%   1916.

% \bibitem[Fif00]{ffgg} Filigran Fifak, Gizbert Gryzogrzechotalski,
%   \textit{O blabalii fetorycznej}, Materiały Konferencji Euroblabal
%   2000.

% \bibitem[Fif01]{ff-sr} Filigran Fifak, \textit{O fetorach
%     $\sigma$-$\rho$}, Acta Fetorica, 2001.

% \bibitem[Głomb04]{grglo} Gryzybór Głombaski, \textit{Parazytonikacja
%     blabiczna fetorów --- nowa teoria wszystkiego}, Warszawa 1904.

% \bibitem[Hopp96]{hopp} Claude Hopper, \textit{On some $\Pi$-hedral
%     surfaces in quasi-quasi space}, Omnius University Press, 1996.

% \bibitem[Leuk00]{leuk} Lechoslav Leukocyt, \textit{Oval mappings ab ovo},
%   Materiały Białostockiej Konferencji Hodowców Drobiu, 2000.

% \bibitem[Rozk93]{JR} Josip A. Rozkosza, \textit{O pewnych własnościach
%     pewnych funkcji}, Północnopomorski Dziennik Matematyczny 63491
%   (1993).

% \bibitem[Spy59]{spyrpt} Mrowclaw Spyrpt, \textit{A matrix is a matrix
%     is a matrix}, Mat. Zburp., 91 (1959) 28--35.

% \bibitem[Sri64]{srinis} Rajagopalachari Sriniswamiramanathan,
%   \textit{Some expansions on the Flausgloten Theorem on locally
%     congested lutches}, J. Math.  Soc., North Bombay, 13 (1964) 72--6.

% \bibitem[Whi25]{russell} Alfred N. Whitehead, Bertrand Russell,
%   \textit{Principia Mathematica}, Cambridge University Press, 1925.

% \bibitem[Zen69]{heu} Zenon Zenon, \textit{Użyteczne heurystyki
%     w blabalizie}, Młody Technik, nr 11, 1969.


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
